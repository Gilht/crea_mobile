import { Component, ViewContainerRef } from '@angular/core';
import { IonicPage, NavController, Platform, ModalController } from 'ionic-angular';
import { AppConfig } from '../../util/AppConfig';
import { CorePage } from '../core/core';
import { MenuController } from 'ionic-angular/components/app/menu-controller';
import { ToastService, ResidentService } from '../../services/services';
import { ServiceUtil, SharedUserService, message, SessionStatus, ApiErrorCodes } from '../../clientsSharedModule/sharedmodule';
import { ScreenOrientation } from '@ionic-native/screen-orientation';
import { SynchroController } from '../../offlinecontrollers/synchroController';
import { SharedService } from '../../services/shared.service';
import { ListModalPage } from '../../modals/listModal/listModal';
import { PolicyAgreementModalPage } from '../../modals/policyAgreementModal/policyAgreementModal';
import { ExpiredSessionModalPage } from '../../modals/expiredSessionModal/expiredSessionModal';
import * as _ from 'lodash';

import 'rxjs/add/operator/toPromise';

@IonicPage()
@Component({
    selector: 'page-login',
    templateUrl: 'login.html',
    providers: [SharedUserService, ScreenOrientation, ResidentService]
})
export class LoginPage {
    resident: any;
    newUser: any = {};
    password: string;
    showPassword: boolean = false;
    passwordInputType: string = 'password';
    loading = false;
    onlineSubscription: any;
    online = false;
    serverVersion: string = AppConfig.getServerVersion();

    constructor(
        public navCtrl: NavController,
        private menu: MenuController,
        private toastService: ToastService,
        private sharedUserService: SharedUserService,
        private screenOrientation: ScreenOrientation,
        public platform: Platform,
        private synchroController: SynchroController,
        private sharedService: SharedService,
        private residentService: ResidentService,
        public modalCtrl: ModalController
    ) {

    }

    ngOnInit() {
        this.screenOrientation.lock(this.screenOrientation.ORIENTATIONS.LANDSCAPE)
        .catch(error => {
            console.error(error.message);
        });

        this.loading = true;
        this.online = this.sharedService.getOnline();
        this.onlineSubscription = this.sharedService.response$.subscribe(
            conn => {
                this.loading = false;
                this.online = conn;
            }
        );

        this.menu.enable(false);
        this.menu.swipeEnable(false);
    }

    login() {
        this.loading = true;

        if (this.online) {
            // Server validations
            this.validateServerVersion().then(() => {
                // This version app version is compatible
                return this.validateLogin();
            }).then(response => {
                // Login credentials are valid on the server
                // Initialize session variables
                localStorage.clear();
                localStorage.setItem('token', response.token);
                localStorage.setItem('CurrentUser', this.newUser.userName);
                localStorage.setItem('UserName', response.userName);
                this.sharedService.setSessionStatus(SessionStatus.Valid);

                return this.checkPoliciesAgreements();
            }).then(() => {
                return this.checkSpecialUser(this.newUser.userName);
            }).then(userFlags => {
                localStorage.setItem('isAuditor', String(userFlags.isAuditor));

                if (userFlags.isAdmin || userFlags.isAuditor) {
                    this.getResidentsModal(this.newUser.userName);
                } else {
                    this.downloadInfo(this.newUser.userName);
                }
            })
            .catch(customErrorWrapper => {
                this.handleServerClientErros(customErrorWrapper);
                this.loading = false;
            });
        } else {
            this.synchroController.hasData().then(res => {
                if (res) {
                    let uname = this.newUser.userName;
                    this.synchroController.get(this.synchroController.models._isAuditorMaps).then(kvals => {
                        const isAuditor = (kvals[uname] != null ? kvals[uname] : false);
                        localStorage.setItem('isAuditor', String(isAuditor));
                        this.onChangeToMainMenu();
                    });
                } else {
                    this.toastService.presentToast(message.loginOffline.error, this.toastService.types.error);
                }

                this.loading = false;
            })
            return;
        }
    }

    private handleServerClientErros(customErrorWrapper) {
        if (customErrorWrapper.type == 'server') {
            // Server Error Handlers
            if (customErrorWrapper.errorResponse.error.code) { // The error was generated by the server
                switch(customErrorWrapper.errorResponse.error.code) {
                    case ApiErrorCodes.USER_IS_NOT_REGISTERED:
                        this.toastService.presentToast("El usuario aún no ha sido registrado en el portal.", this.toastService.types.error);
                        break;
                    case ApiErrorCodes.USER_WRONG_USERNAME_PASSWORD:
                        this.toastService.presentToast("El usuario o contraseña son incorrectos.", this.toastService.types.error);
                        break;
                    case ApiErrorCodes.USER_NOT_ACCEPTED_PRIVACY_POLICY:
                        this.toastService.presentToast("El usuario aún no ha aceptado el aviso de privacidad.", this.toastService.types.error);
                        break;
                    case ApiErrorCodes.USER_NO_ASSIGNED_SECTION_HOUSES:
                        this.toastService.presentToast("El usuario no tiene viviendas asignadas.", this.toastService.types.error);
                        break;
                    case ApiErrorCodes.GENERAL_GENERATING_RESPONSE:
                        this.toastService.presentToast("Error al generar la respuesta en el servidor.", this.toastService.types.error);
                        break;
                    case ApiErrorCodes.GENERAL_CALLING_WEB_SERVICE:
                        this.toastService.presentToast("Error al llamar al web service externo en el servidor.", this.toastService.types.error);
                        break;
                    default:
                        console.info('Server error...', customErrorWrapper.errorResponse);
                        this.toastService.presentToast("Error de conexión.", this.toastService.types.error);
                        break;
                }
            } else { // Other error (connection problem / crash / old server error)
                console.error(customErrorWrapper);
                this.toastService.presentToast(message.error, this.toastService.types.error);
            }
        } else {
            // App Error Handlers
            switch(customErrorWrapper.clientCode) {
                case 'CLIENT_VERSION_NOT_COMPATIBLE':
                    this.showVersionModal();
                    break;
                case 'USER_WRONG_USERNAME_PASSWORD':
                    this.toastService.presentToast(message.credentials, this.toastService.types.warning);
                    break;
                case 'USER_DENIED_PRIVACY_POLICY':
                    this.toastService.presentToast('Es necesario aceptar la política de privacidad para iniciar sesión.', this.toastService.types.warning);
                    break;
                default:
                    this.toastService.presentToast(message.error, this.toastService.types.error);
                    console.info('Client error...', customErrorWrapper);
                    break;
            }
        }
    }

    private validateServerVersion(): Promise<any> {
        // On success forward response
        return this.sharedUserService.checkServerVersion(AppConfig.version, AppConfig.desiredServerVersion, true)
        .toPromise()
        .then(response => {
            if (!response.hasOwnProperty('isCompatible') || (response && !response.isCompatible)) {
                throw {
                    type: 'client',
                    clientCode: 'CLIENT_VERSION_NOT_COMPATIBLE'
                };
            }
        }).catch(error => {
            // Check if it's a user defined error
            if (error.hasOwnProperty('type') && error.type == 'client') {
                throw error;
            } else {
                throw {
                    type: 'server',
                    errorResponse: error
                };
            }
        });
    }

    private validateLogin(): Promise<any> {
        return new Promise((resolve, reject) => {
            if (_.isEmpty(this.newUser.userName) || _.isEmpty(this.newUser.password)) {
                return reject({
                    type: 'client',
                    clientCode: 'USER_WRONG_USERNAME_PASSWORD'
                });
            } else {
                return resolve();
            }
        }).then(() => {
            return this.sharedUserService.login(this.newUser, true)
            .toPromise();
        });
    }

    private checkPoliciesAgreements(): Promise<any> {
        return this.sharedUserService.checkPoliciesAgreements(this.newUser.userName)
        .toPromise()
        .catch(errorResponse => {

            const evalModal = (policiesErrors) => {
                let policyError = policiesErrors.shift();
                let promise = Promise.resolve();

                if (policyError.code == ApiErrorCodes.USER_NOT_ACCEPTED_PRIVACY_POLICY) {
                    promise = this.showPrivacyPolicyModal();
                }

                if (policiesErrors.length == 0) {
                    return promise;
                } else {
                    return promise.then(() => {
                        return evalModal(policiesErrors);
                    });
                }
            }


            // The error is handled here to return the modal as an additional validation
            if (errorResponse.error.policiesErrors) {
                return evalModal(errorResponse.error.policiesErrors)
                .then(() => this.checkPoliciesAgreements());
            } else {
                // throw any other server error
                throw {
                    type: 'server',
                    errorResponse
                };
            }
        });
    }

    private checkSpecialUser(username): Promise<any> {
        return this.sharedUserService.getPermissions(username)
        .toPromise()
        .then(response => {
            return {
                isAdmin: (response && response.permissions.isAdmin),
                // At the moment the way to tell a user is auditor is based on a specific permission
                // and it will be the only permission for the app because the app does not implement permissions
                isAuditor: (response && response.access.length > 0)
            };

        }).catch(error => {
            throw {
                type: 'server',
                errorResponse: error
            };
        });
    }

    changePasswordInputType() {
        if (this.showPassword) {
            this.passwordInputType = "text";
        } else {
            this.passwordInputType = "password";
        }
    }

    getResidentsModal(username) {
        this.residentService.getAdminResidents()
            .subscribe(
                result => {
                    this.loading = false;
                    this.getListModal(result, username);
                },
                error => {
                    this.toastService.presentToast(message.error, this.toastService.types.error);
                    this.loading = false;
                });
    }

    getListModal(list, username) {
        let modal = this.modalCtrl.create(ListModalPage, { list: list, title: 'Seleccione un Residente', displayProperty: 'login' });
        modal.onDidDismiss(data => {
            this.downloadInfo(data.result.login);
        });
        modal.present();
    }

    showPrivacyPolicyModal() {
        return this.sharedUserService.getServicePolicy('privacyPolicy')
        .toPromise()
        .then(policy => {
            return new Promise((resolve, reject) => {
                let modal = this.modalCtrl.create(PolicyAgreementModalPage, {
                    policyObject: policy
                });

                modal.present();

                modal.onDidDismiss(response => {
                    if (response && response.policyAccepted == true) {
                        return resolve();
                    } else {
                        reject({
                            type: 'client',
                            clientCode: 'USER_DENIED_PRIVACY_POLICY'
                        });
                    }
                });
            });
        }).then(() => {
            // The policy was accepted in the modal so we
            // do an update on the server and validate again
            return this.sharedUserService.updateLatestAgreedServicePolicy(this.newUser.userName, 'privacyPolicy')
            .toPromise();
        });
    }

    showVersionModal() {
        const modal = this.modalCtrl.create(ExpiredSessionModalPage, { title: 'Versión Incompatible', message: message.version.incompatibleHTML }, { cssClass: 'unauthorized-modal', enableBackdropDismiss: false });
        modal.onDidDismiss((data) => {
            this.platform.exitApp();
        });
        modal.present();
    }


    onChangeToMainMenu() {
        this.navCtrl.setRoot("CorePage", { cameFromLogin: true });
    }

    ionViewWillUnload() {
        if (this.onlineSubscription) {
            this.onlineSubscription.unsubscribe();
        }
    }

    downloadInfo(username) {
        if (!username)
            return;
        this.synchroController.hasData().then(res => {
            if (!res) {
                this.download(username);
            } else if (res.login == username) {
                this.onChangeToMainMenu();
            } else {
                this.download(username);
            }
        })
    }

    download(login) {
        this.loading = true;
        this.synchroController.download(login).then(x => {
            this.synchroController.saveIsAuditor(this.newUser.userName, ServiceUtil.getIsAuditor()).then(() => {
                this.loading = false;
                this.onChangeToMainMenu();
                this.toastService.presentToast(message.download.success, this.toastService.types.success);
            });
        }).catch(error => {
            this.toastService.presentToast(message.error, this.toastService.types.error);
            this.loading = false;
        });
    }
}
